"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var declarations_1 = require("../declarations");
var assign_json_schema_1 = require("./assign-json-schema");
var utils_1 = require("./utils");
function buildForeignKey(builder, _a) {
    var foreignKeyName = _a.foreignKeyName, alterSource = _a.alterSource, source = _a.source, target = _a.target;
    return builder.foreign(source.field, foreignKeyName)
        .references(target.field).inTable(target.tableName);
}
exports.buildForeignKey = buildForeignKey;
function implTableAnnotation(builder, _a, refs) {
    var uniques = _a.uniques, indexes = _a.indexes, keys = _a.keys;
    var calcKeys = utils_1.wrapArray(keys);
    if (calcKeys.length) {
        builder.primary(calcKeys);
    }
    if (Array.isArray(uniques)) {
        uniques.forEach(function (item) {
            if (item) {
                if (typeof item === 'string') {
                    builder.unique([item]);
                }
                else if (Array.isArray(item)) {
                    builder.unique(item);
                }
                else if (typeof item === 'object') {
                    builder.unique(utils_1.wrapArray(item.fields), item.name);
                }
            }
        });
    }
    if (Array.isArray(indexes)) {
        indexes.forEach(function (item) {
            if (item) {
                if (typeof item === 'string') {
                    builder.index([item]);
                }
                else if (Array.isArray(item)) {
                    builder.index(item);
                }
                else if (typeof item === 'object') {
                    builder.index(utils_1.wrapArray(item.fields), item.name, item.type);
                }
            }
        });
    }
    Object.values(refs).forEach(function (refFn) {
        buildForeignKey(builder, refFn());
    });
}
function secondBuilderParam(_a) {
    var opts = _a.opts, type = _a.type;
    switch (type) {
        case 'text':
            return opts.textType;
        case 'string':
            return opts.schema && opts.schema.maxLength;
    }
    return undefined;
}
exports.secondBuilderParam = secondBuilderParam;
function buildAdditionalColSchema(colProto, opts) {
    if (opts.unique) {
        colProto.unique(typeof opts.unique === 'string' ? opts.unique : undefined);
    }
    else if (opts.index) {
        colProto.index(typeof opts.index === 'string' ? opts.index : undefined);
    }
    if (opts.default !== void 0) {
        colProto.defaultTo(opts.default);
    }
    if (opts.required) {
        colProto.notNullable();
    }
    if (opts.unsigned) {
        colProto.unsigned();
    }
}
function buildTableFromBuilder(builder, modelClass, refs) {
    var _a;
    var tableOpts = utils_1.getMeta(modelClass, declarations_1.META_ANN_SCHEMA);
    var colSchemas = utils_1.getMeta(modelClass, declarations_1.META_ANN_SCHEMA_COL);
    var keys = utils_1.wrapArray(tableOpts.keys || modelClass.idColumn);
    var refKeys = Object.keys(refs);
    for (var colName in colSchemas) {
        var schemaFn = colSchemas[colName];
        var schema = typeof schemaFn === 'function' && schemaFn();
        var _b = assign_json_schema_1.resolveColumnAnnotations(schema, schema && typeof schema['type'] === 'function'), type = _b.type, opts = _b.opts;
        if (typeof type !== 'string') {
            continue;
        }
        var hasOpt = typeof opts === 'object' && opts;
        var colProto = builder[type](colName, hasOpt && (secondBuilderParam({ type: type, opts: opts })) || undefined);
        if (type === 'increments' || type === 'bigIncrements') {
            keys = [];
        }
        if (hasOpt) {
            if (keys.includes(colName) || refKeys.includes(colName)) {
                if (opts.unsigned === void 0) {
                    opts.unsigned = true;
                }
            }
            buildAdditionalColSchema(colProto, opts);
        }
        utils_1.appendMeta(modelClass, declarations_1.META_COL_BUILDER, (_a = {}, _a[colName] = colProto, _a));
    }
    implTableAnnotation(builder, tslib_1.__assign({}, tableOpts, { keys: keys }), refs);
}
exports.buildTableFromBuilder = buildTableFromBuilder;
