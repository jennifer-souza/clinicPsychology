"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var declarations_1 = require("../declarations");
var assign_json_schema_1 = require("./assign-json-schema");
var builder_1 = require("./builder");
var utils_1 = require("./utils");
function alterSourceForForeignKey(builder, _a) {
    var _b;
    var alterSource = _a.alterSource, source = _a.source, target = _a.target;
    var meta = utils_1.getMeta(source.modelClass, declarations_1.META_COL_BUILDER);
    var colProto = meta && meta[source.field];
    var targetSchemas = utils_1.getMeta(target.modelClass, declarations_1.META_ANN_SCHEMA_COL);
    var targetSchemaFn = targetSchemas && targetSchemas[target.field];
    var _c = assign_json_schema_1.resolveColumnAnnotations(typeof targetSchemaFn === 'function' && targetSchemaFn() || {}), targetType = _c.type, opts = _c.opts;
    var unsigned = false;
    var type = 'integer';
    var alter = !!colProto;
    if (alter) {
        unsigned = ['increments', 'bigIncrements'].includes(targetType);
    }
    if (targetType && targetType !== 'increments') {
        if (targetType === 'increments') {
            unsigned = true;
        }
        else if (targetType === 'bigIncrements') {
            unsigned = true;
            type = 'bigInteger';
        }
        else {
            type = targetType;
        }
    }
    var hasOpt = typeof opts === 'object' && opts;
    colProto = builder[type](source.field, hasOpt && (builder_1.secondBuilderParam({ type: type, opts: opts })) || undefined);
    utils_1.appendMeta(source.modelClass, declarations_1.META_COL_BUILDER, (_b = {}, _b[source.field] = colProto, _b));
    if (unsigned) {
        colProto.unsigned();
    }
    if (alterSource === 'required') {
        colProto.notNullable();
    }
    if (alter) {
        colProto.alter();
    }
    return colProto;
}
function executeHasRefs(knex, modelClasses) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var foreignInfos, _i, modelClasses_1, m, hasRefFns, _a, hasRefFns_1, hasRefFn, foreignInfo, source, target, sourceRefs, foreignGrp, _loop_1, _b, foreignGrp_1, _c, tableName, infos;
        return tslib_1.__generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    foreignInfos = [];
                    for (_i = 0, modelClasses_1 = modelClasses; _i < modelClasses_1.length; _i++) {
                        m = modelClasses_1[_i];
                        hasRefFns = utils_1.getMeta(m, declarations_1.META_ANN_HAS_REFS);
                        if (Array.isArray(hasRefFns)) {
                            for (_a = 0, hasRefFns_1 = hasRefFns; _a < hasRefFns_1.length; _a++) {
                                hasRefFn = hasRefFns_1[_a];
                                foreignInfo = typeof hasRefFn === 'function' && hasRefFn()
                                    || {};
                                source = foreignInfo.source, target = foreignInfo.target;
                                if (source && target && modelClasses.includes(source.modelClass)) {
                                    sourceRefs = utils_1.getMeta(source.modelClass, declarations_1.META_ANN_REFS);
                                    if (!sourceRefs[source.field]) {
                                        foreignInfos.push(foreignInfo);
                                    }
                                }
                            }
                        }
                    }
                    foreignGrp = Object.entries(foreignInfos.reduce(function (prv, info) {
                        var _a;
                        return (tslib_1.__assign({}, prv, (_a = {}, _a[info.source.tableName] = (prv[info.source.tableName] || []).concat([info]), _a)));
                    }, {}));
                    _loop_1 = function (tableName, infos) {
                        return tslib_1.__generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4, knex.schema.alterTable(tableName, function (builder) {
                                        infos.filter(function (info) { return !!info.alterSource; })
                                            .forEach(function (info) { return alterSourceForForeignKey(builder, info); });
                                    })];
                                case 1:
                                    _a.sent();
                                    return [4, knex.schema.alterTable(tableName, function (builder) {
                                            infos.forEach(function (info) { return builder_1.buildForeignKey(builder, info); });
                                        })];
                                case 2:
                                    _a.sent();
                                    return [2];
                            }
                        });
                    };
                    _b = 0, foreignGrp_1 = foreignGrp;
                    _d.label = 1;
                case 1:
                    if (!(_b < foreignGrp_1.length)) return [3, 4];
                    _c = foreignGrp_1[_b], tableName = _c[0], infos = _c[1];
                    return [5, _loop_1(tableName, infos)];
                case 2:
                    _d.sent();
                    _d.label = 3;
                case 3:
                    _b++;
                    return [3, 1];
                case 4: return [2];
            }
        });
    });
}
exports.executeHasRefs = executeHasRefs;
