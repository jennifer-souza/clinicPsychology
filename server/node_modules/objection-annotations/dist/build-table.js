"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var objection_1 = require("objection");
var declarations_1 = require("./declarations");
var assign_json_schema_1 = require("./internals/assign-json-schema");
var builder_1 = require("./internals/builder");
var builder_has_refs_1 = require("./internals/builder-has-refs");
var utils_1 = require("./internals/utils");
function buildTable(knex) {
    var modelClasses = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        modelClasses[_i - 1] = arguments[_i];
    }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        function createTable(modelClass) {
            return tslib_1.__awaiter(this, void 0, void 0, function () {
                var tableName, _a, refs_1, _b, _c, _i, refKey, refModelClass, resolvedRefModelClass;
                return tslib_1.__generator(this, function (_d) {
                    switch (_d.label) {
                        case 0:
                            tableName = modelClass.tableName;
                            _a = !processedModels.includes(modelClass);
                            if (!_a) return [3, 2];
                            return [4, knex.schema.hasTable(tableName)];
                        case 1:
                            _a = !(_d.sent());
                            _d.label = 2;
                        case 2:
                            if (!_a) return [3, 8];
                            refs_1 = utils_1.getMeta(modelClass, declarations_1.META_ANN_REFS);
                            _b = [];
                            for (_c in refs_1)
                                _b.push(_c);
                            _i = 0;
                            _d.label = 3;
                        case 3:
                            if (!(_i < _b.length)) return [3, 6];
                            refKey = _b[_i];
                            refModelClass = refs_1[refKey]().target.modelClass;
                            resolvedRefModelClass = declarations_1.resolveModelClass(refModelClass);
                            if (!(resolvedRefModelClass !== modelClass)) return [3, 5];
                            return [4, createTable(resolvedRefModelClass)];
                        case 4:
                            _d.sent();
                            _d.label = 5;
                        case 5:
                            _i++;
                            return [3, 3];
                        case 6: return [4, knex.schema.createTable(tableName, function (builder) {
                                builder_1.buildTableFromBuilder(builder, modelClass, refs_1);
                            })];
                        case 7:
                            if (_d.sent()) {
                                processedModels.push(modelClass);
                            }
                            _d.label = 8;
                        case 8: return [2];
                    }
                });
            });
        }
        var processedModels, _a, modelClasses_1, m;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    objection_1.Model.knex(knex);
                    processedModels = [];
                    _a = 0, modelClasses_1 = modelClasses;
                    _b.label = 1;
                case 1:
                    if (!(_a < modelClasses_1.length)) return [3, 4];
                    m = modelClasses_1[_a];
                    return [4, createTable(m)];
                case 2:
                    _b.sent();
                    _b.label = 3;
                case 3:
                    _a++;
                    return [3, 1];
                case 4: return [4, builder_has_refs_1.executeHasRefs(knex, processedModels)];
                case 5:
                    _b.sent();
                    modelClasses.forEach(function (m) { return assign_json_schema_1.assignJsonSchema(m); });
                    return [2, processedModels];
            }
        });
    });
}
exports.buildTable = buildTable;
